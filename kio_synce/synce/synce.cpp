#include <sys/types.h>
#include <sys/stat.h>

#include <qcstring.h>
#include <qsocket.h>
#include <qdatetime.h>
#include <qbitarray.h>

#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#include <kapp.h>
#include <kdebug.h>
#include <kmessagebox.h>
#include <kinstance.h>
#include <kglobal.h>
#include <kstddirs.h>
#include <klocale.h>
#include <kurl.h>
#include <ksock.h>

#include "synce.h"

//
// The kdemain function was generated by KDevelop, how nice
//
using namespace KIO;
extern "C"
{
  int kdemain( int argc, char **argv )
  {
    KInstance instance( "kio_synce" );
    
    kdDebug(7101) << "*** Starting kio_synce " << endl;
    
    if (argc != 4)
      {
	kdDebug(7101) << "Usage: kio_synce  protocol domain-socket1 domain-socket2" << endl;
	exit(-1);
      }
    
    kio_synceProtocol slave(argv[2], argv[3]);
    slave.dispatchLoop();
    
    kdDebug(7101) << "*** kio_synce Done" << endl;
    return 0;
  }
} 

kio_synceProtocol::kio_synceProtocol(const QCString &pool_socket, const QCString &app_socket)
  : SlaveBase("kio_synce", pool_socket, app_socket), mIsInitialized(false)
{
 kdDebug() << "kio_synceProtocol::kio_synceProtocol()" << endl;
}
/* ---------------------------------------------------------------------------------- */


kio_synceProtocol::~kio_synceProtocol()
{
  kdDebug() << "kio_synceProtocol::~kio_synceProtocol()" << endl;
	uninit();
}

//
// This is a helper class that does ugly conversions between QString and WCHAR*
//
class RapiString
{
private:
	mutable QString* mpQtString;
	mutable RAPI::WCHAR* mpWcharString;

public:
	RapiString(const QString& str)
		: mpQtString(new QString(str)), mpWcharString(NULL)
	{
	}

	RapiString(const RAPI::WCHAR* str)
		: mpQtString(NULL), mpWcharString(NULL)
	{
		mpWcharString = new RAPI::WCHAR[RAPI::wcslen(str)+1];
		RAPI::wcscpy(mpWcharString, str);
	}

	virtual ~RapiString()
	{
		if (mpWcharString)
			delete mpWcharString;

		if (mpQtString)
			delete mpQtString;
	}
		

	operator const RAPI::WCHAR*() const
	{
		if (!mpWcharString)
		{
			mpWcharString = new RAPI::WCHAR[mpQtString->length()+1];
			unsigned i;
			for (i = 0; i < mpQtString->length(); i++)
				mpWcharString[i] = mpQtString->at(i).unicode();
			mpWcharString[i] = 0;
		}

		return mpWcharString;
	}

	operator const QString&() const
	{
		if (!mpQtString)
		{
			mpQtString = new QString();
			mpQtString->setUnicodeCodes(mpWcharString, RAPI::wcslen(mpWcharString));
		}

		return *mpQtString;
	}
};

//
// This converts from a CE_FIND_DATA structure to a UDSEntry
//
void kio_synceProtocol::createUDSEntry( const RAPI::CE_FIND_DATA* source, UDSEntry & destination )
{
//  kdDebug(7101) << "[kio_synceProtocol::createUDSEntry]" << endl;

  UDSAtom atom;
  destination.clear();

	RapiString name(source->cFileName);
  
//	kdDebug(7101) << "name=" << static_cast<QString>(name) << endl;

  atom.m_uds = UDS_NAME;
  atom.m_str = name;
  destination.append(atom);

	atom.m_uds = KIO::UDS_FILE_TYPE;
	if (source->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		atom.m_long = S_IFDIR;
	else
		atom.m_long = S_IFREG;
	destination.append(atom);

	atom.m_uds = UDS_ACCESS;
	atom.m_long = 0777;
	destination.append(atom);

	atom.m_uds = UDS_SIZE;
	atom.m_long = source->nFileSizeLow;
	destination.append( atom );
}

//
// Read a file
//
void kio_synceProtocol::get(const KURL& url )
{
  kdDebug() << "kio_synce::get(const KURL& url)" << endl ;

	RapiString rapi_path(slashToBackslash(url.path()));
	
	// Open file for reading, fail if it does not exist
	RAPI::HANDLE handle = RAPI::CeCreateFile(
				rapi_path, 
				GENERIC_READ, 
				0, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);

	if ((RAPI::HANDLE)-1 == handle)
	{
  	kdDebug(7101) << "[kio_synceProtocol::stat] CeCreateFile failed with error code " << RAPI::CeGetLastError() << endl;
		error(KIO::ERR_DOES_NOT_EXIST, url.path());
		return;
	}

	// TODO: call totalSize() with total file size

	// Read data from file
	static const size_t BUFFER_SIZE = 16*1024;
	
	QByteArray buffer;
	unsigned total_read = 0;
	unsigned part_read = 0;
	do
	{
		buffer.resize(BUFFER_SIZE);
		
		RAPI::BOOL success = RAPI::CeReadFile(
				handle, 
				buffer.data(), 
				BUFFER_SIZE, 
				&part_read, 
				NULL);

		if (!success)
		{
			kdDebug(7101) << "[kio_synceProtocol::stat] CeReadFile failed with error code " << RAPI::CeGetLastError() << endl;
			error(KIO::ERR_COULD_NOT_READ, url.path());
			return;
		}

		buffer.resize(part_read);
		data(buffer);
	
		total_read += part_read;
		processedSize(total_read);
	}
	while(part_read);

  finished();
}


/* ---------------------------------------------------------------------------------- */

//
// Get info about a file or directory
//
void kio_synceProtocol::stat(const KURL & url)
{
  kdDebug(7101) << "[kio_synceProtocol::stat]" << endl;

	QString path(slashToBackslash(url.path()));

	//
	// Special case: root directory
	//
	if (path == QString::fromLatin1("\\"))
	{
  	kdDebug(7101) << "[kio_synceProtocol::stat] Root directory" << endl;
	
  	UDSEntry entry;
		UDSAtom atom;

		atom.m_uds = KIO::UDS_NAME;
		atom.m_str = url.fileName();
		entry.append(atom);
	
		atom.m_uds = KIO::UDS_FILE_TYPE;
		atom.m_long = S_IFDIR;
		entry.append( atom );

		statEntry(entry);
	
		finished();
		return;
	}

	//
	// If we get a path ending with a backslash, we want to exclude it
	// before we continue
	//
	else if (path[path.length()-1].latin1() == '\\')
	{
		path = path.left(path.length()-1);
	}
	
	// Initialize RAPI if needed
	if (!init())
		return;

	RapiString rapi_path(path);

	RAPI::CE_FIND_DATA find_data;
	memset(&find_data, 0, sizeof(find_data));
	
	RAPI::HANDLE handle = RAPI::CeFindFirstFile(rapi_path, &find_data);

	if ((RAPI::HANDLE)-1 == handle)
	{
  	kdDebug(7101) << "[kio_synceProtocol::stat] CeFindFirstFile failed with error code " << RAPI::CeGetLastError() << endl;
		error(KIO::ERR_DOES_NOT_EXIST, url.path());
		return;
	}

  UDSEntry entry;
	createUDSEntry(&find_data, entry);
	statEntry(entry);

	finished();
}


/* --------------------------------------------------------------------------- */


//
// List the contents of a directory
//
// TODO: use FindFirstFile/FindNextFile and not FindAllFiles
//
void kio_synceProtocol::listDir( const KURL & url )
{
  kdDebug(7101) << "[kio_synceProtocol::listDir]" << endl;

	// Initialize RAPI if needed
	if (!init())
		return;

	QString pattern(slashToBackslash(url.path()));
	if (pattern[pattern.length()-1].latin1() != '\\')
	{
		KURL redir( QString::fromLatin1( "synce:/") );
		redir.setPath( url.path() + QString::fromLatin1("/") );
		redirection( redir );
		finished();
		return;
	}
	
	pattern.append(QString::fromLatin1("*.*"));
	kdDebug(7101) << "[kio_synceProtocol::listDir] Searching for \"" << pattern << "\"" << endl;
	
	RapiString rapi_pattern(pattern);

	RAPI::CE_FIND_DATA* find_data = NULL;
	RAPI::DWORD file_count = 0;
	
	RAPI::CeFindAllFiles(rapi_pattern, 
			FAF_ATTRIBUTES|FAF_NAME|FAF_SIZE_LOW,
			&file_count, &find_data);

  UDSEntry entry;
	for (unsigned i = 0; i < file_count; i++)
	{
		createUDSEntry(find_data + i, entry);
		listEntry(entry, false);
	}

  listEntry( entry, true ); // ready

	RAPI::CeRapiFreeBuffer(find_data);


  finished();
}

//
// Helper function to initialize the RAPI library
//
// Returns true on success and false on failure
//
bool kio_synceProtocol::init()
{
	if (!mIsInitialized)
	{
		RAPI::HRESULT result = RAPI::CeRapiInit();

		mIsInitialized = (0 == result);
		if (!mIsInitialized)
		{
			error(KIO::ERR_COULD_NOT_CONNECT, QString::fromLatin1("Unable to initialize RAPI"));
		}
	}

	return mIsInitialized;
}

//
// Uninitialize the RAPI library
//
void kio_synceProtocol::uninit()
{
	if (mIsInitialized)
	{
		RAPI::CeRapiUninit();
		mIsInitialized = false;
	}
}

//
// Convert forward slashes ('/') to back-slashes ('\')
//
QString kio_synceProtocol::slashToBackslash(const QString& path)
{
	QString tmp(path);
	for (unsigned i = 0; i < tmp.length(); i++)
	{
		if (tmp[i].latin1() == '/')
			tmp[i] = QChar('\\');
	}
	return tmp;
}

